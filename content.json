{"meta":{"title":"木子Jerry Blog","subtitle":null,"description":"新人开博客，学习、交流","author":"LiXingJun","url":"http://hellomrli.github.io"},"pages":[],"posts":[{"title":"Unity3d之常遇问题整理","slug":"Unity3d之常遇问题整理","date":"2017-02-05T04:47:15.000Z","updated":"2017-02-05T08:56:10.000Z","comments":true,"path":"2017/02/05/Unity3d之常遇问题整理/","link":"","permalink":"http://hellomrli.github.io/2017/02/05/Unity3d之常遇问题整理/","excerpt":"","text":"整理一些unity开发中遇到的问题，文档持续更新！ 1.unity和vs开发中，每次双击脚本都会弹出一个新的vs窗口问题解决方法：删除根目录下的vs相关程序集文件即可。","categories":[{"name":"unity","slug":"unity","permalink":"http://hellomrli.github.io/categories/unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"http://hellomrli.github.io/tags/unity/"},{"name":"MonoBehaviour","slug":"MonoBehaviour","permalink":"http://hellomrli.github.io/tags/MonoBehaviour/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-01-09T12:27:41.880Z","updated":"2017-01-10T13:30:44.000Z","comments":true,"path":"2017/01/09/hello-world/","link":"","permalink":"http://hellomrli.github.io/2017/01/09/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Unity3d之EventTrigger","slug":"Unity3d之EventTrigger","date":"2017-01-09T04:47:15.000Z","updated":"2017-02-05T08:51:34.000Z","comments":true,"path":"2017/01/09/Unity3d之EventTrigger/","link":"","permalink":"http://hellomrli.github.io/2017/01/09/Unity3d之EventTrigger/","excerpt":"开发了新的UI系统UGUI，附带的事件系统EventSystem不仅可以用于UI，对于场景中的对象也同样适用。网络上有很多使用说明，但是仅仅是怎么用而已……这篇文章是我翻了无数遍官方手册整理出来的，包括自己的理解，还有官方文档的传送门，也许你会有兴趣。","text":"开发了新的UI系统UGUI，附带的事件系统EventSystem不仅可以用于UI，对于场景中的对象也同样适用。网络上有很多使用说明，但是仅仅是怎么用而已……这篇文章是我翻了无数遍官方手册整理出来的，包括自己的理解，还有官方文档的传送门，也许你会有兴趣。 一、 EventSystem对象的说明当我们在场景中创建任一UI对象后，Hierarchy面板中都可以看到系统自动创建了对象EventSystem，可以看到该对象下有三个组件：EventSystem、StandaloneInputModule、TouchInputModule，后面两个组件都继承自BaseInputModule。EventSystem组件主要负责处理输入、射线投射以及发送事件。一个场景中只能有一个EventSystem组件，并且需要BaseInputModule类型组件的协助才能工作。EventSystem在一开始的时候会把自己所属对象下的BaseInputModule类型组件加到一个内部列表，并且在每个Update周期通过接口UpdateModules接口调用这些基本输入模块的UpdateModule接口，然后BaseInputModule会在UpdateModule接口中将自己的状态修改成’Updated’，之后BaseInputModule的Process接口才会被调用。BaseInputModule是一个基类模块，负责发送输入事件（点击、拖拽、选中等）到具体对象。EventSystem下的所有输入模块都必须继承自BaseInputModule组件。StandaloneInputModule和TouchInputModule组件是系统提供的标准输入模块和触摸输入模块，我们可以通过继承BaseInputModule实现自己的输入模块。除了以上两个组件，还有一个很重要的组件通过EventSystem对象我们看不到，它是BaseRaycaster组件。BaseRaycaster也是一个基类，前面说的输入模块要检测到鼠标事件必须有射线投射组件才能确定目标对象。系统实现的射线投射类组件有PhysicsRaycaster, Physics2DRaycaster, GraphicRaycaster。这个模块也是可以自己继承BaseRaycaster实现个性化定制。总的来说，EventSystem负责管理，BaseInputModule负责输入，BaseRaycaster负责确定目标对象，目标对象负责接收事件并处理，然后一个完整的事件系统就有了。另外，其实这些说明官方都有提供，这里也就是把英文译成了中文，并整理下，加上自己的理解，有问题的地方请各路神仙多多指教。官方文档在这里： http://docs.unity3d.com/ScriptReference/EventSystems.EventSystem.html 二、UGUI中的事件系统根据第一节中的说明，EventSystem和BaseInputModule是粘在一个对象上的，这两个模块在EventSystem对象上可以直接看到。那么，BaseRaycaster模块呢。。。其实射线检测，肯定是从摄像机发起的，那么BaseRaycaster模块也一定和摄像机关系一定不简单。对于UI模块，在Canvas对象下我们可以看到GraphicRaycaster组件。如果Canvas的渲染模式是SceenSpace-Overlay，那么我们是看不到Camera组件的。所以应该是GraphicRaycaster会对UI不同的渲染模式做特殊处理。因为有GraphicRaycaster组件的原因，Canvas上的所有UI对象，都可以接受输入模块发出的事件，具体事件的处理在第四节说明。 三、场景对象中使用事件系统场景中的非UI对象，如果想要接收输入模块的事件，一样的道理，也需要给摄像机挂上一个射线检测组件。PhysicsRaycaster, Physics2Draycaster这两个组件分别是用于3D和2D的场景。当然，还需要场景的对象挂了collider射线才检测的到。 其实官方对射线检测也是做了说明的，如果不详读手册是不会发现的，这里是传送门：http://docs.unity3d.com/Manual/Raycasters.html 如果场景中只有一个射线检测源：When a Raycaster is present and enabled in the scene it will be used by the EventSystem whenever a query is issued from an InputModule.如果场景中有多个射线检测源：If multiple Raycasters are used then they will all have casting happen against them and the results will be sorted based on distance to the elements. 四、响应事件1、输入模块可以检测到的 事件 StandaloneInputModule和TouchInputModule两个组件会检测一些输入操作，以事件的方式（message系统）通知目标对象，那么这两个组件支持的事件主要有以下： 1. IPointerEnterHandler OnPointerEnter Called when a pointer enters the object 2. IPointerExitHandler OnPointerExit Called when a pointer exits the object 3. IPointerDownHandler OnPointerDown Called when a pointer is pressed on the object 4. IPointerUpHandler OnPointerUp Called when a pointer is released (called on the original the pressed object) 5. IPointerClickHandler OnPointerClick Called when a pointer is pressed and released on the same object 6. IInitializePotentialDragHandler OnInitializePotentialDrag Called when a drag target is found, can be used to initialise values 7. IBeginDragHandler OnBeginDrag Called on the drag object when dragging is about to begin 8. IDragHandler OnDrag Called on the drag object when a drag is happening 9. 9. IEndDragHandler OnEndDrag Called on the drag object when a drag finishes 10. 10. IDropHandler OnDrop Called on the object where a drag finishes 11. 11. IScrollHandler OnScroll Called when a mouse wheel scrolls 12. 12. IUpdateSelectedHandler OnUpdateSelected Called on the selected object each tick 13. ISelectHandler OnSelect Called when the object becomes the selected object 14. IDeselectHandler OnDeselect Called on the selected object becomes deselected 15. IMoveHandler OnMove Called when a move event occurs (left, right, up, down, ect) 16. ISubmitHandler OnSubmit Called when the submit button is pressed 17. ICancelHandler OnCancel Called when the cancel button is pressed 只要目标对象的mono脚本实现了以上接口，那么输入模块会将检测到的事件通过这些接口通知给目标对象。参考：http://docs.unity3d.com/Manual/SupportedEvents.html如果你自定义了自己的输入模块，那么以上这些事件肯定是不能用的了。 2、接收输入事件的方式 1）、自行继承接口实现监听 在mono脚本中继承输入模块提供的事件接口，如下图。接口的定义方式也可以查下官方手册，http://docs.unity3d.com/ScriptReference/EventSystems.IBeginDragHandler.html 这边有每一个接口的定义方式，放心大胆地点进去。另外，添加ObjChooseEvent组件的对象，一定要有Collider哦。 2）、 通过EventTrigger组件监听事件 这是一个官方组件。在需要监听事件的对象上，挂上这个组件，然后在Inspector面板展开配置，你会看到这个组件提供了所有输入模块支持的事件类型的监听，如下图。 这种方式的优点是，当你选中一个你要监听的类型，你可以为这个事件类型添加多个监听接口，统一管理，可以清楚的知道到底哪些地方响应了这个事件呢。如果是继承Interface的方式，它将会分散在N个脚本里，一旦出现问题，那查起来一定会很酸爽。 但是这种通过配置的方式，一旦项目多人协作，项目的复杂度起来，这种拖来拽去的配置终究是会有很多问题的，比如某个组件删除，比如响应接口改了个名字~~都会导致配置丢失，而问题又不能及时发现。又或者程序的监听接口因为某些条件而不同。所以也许你会需要第三种方式。 3）、动态添加EventTrigger组件或者修改组件 其实http://www.cnblogs.com/zou90512/p/3995932.html 这位同学的博客对这三种方法都做了很详细的说明。 只不过EventTrigger对外提供的接口不是很友好，导致我们需要添加一个监听，仿佛绕了N了山路弯弯，看着就心情不愉快……反而是这位博主后面说的Button的Click事件的实现方式有点意思……如果项目有需要，也许我们也可以这么做…… 五、EventSystem组件提供的一些有意思的接口其实文档都有http://docs.unity3d.com/ScriptReference/EventSystems.EventSystem.html 只是也许你没有注意。点击EventSystem对象，你可以看到运行时候的一些详细数据： 变量： firstSelectedGameObject：这个值可以在面板设置，如果你需要游戏在启动的时候自动选中某个对象，需要鼠标的那一下点击。 currentSelectedGameObject：当前选中的对象，你可以通过这个值判断当前是否鼠标点击在对象上，因为也许你有拖动摄像机的功能，但是你又不喜欢点击某些对象的时候这个功能又被响应，所以通过这个变量判断是一个很好的办法。 接口： IsPointerOverGameObject：当前鼠标是否在事件系统可以检测的对象上。 SetSelectedGameObject：这个接口也许你会忽略，但是它很棒。因为你点击场景对象的时候，如果不调用这个接口，你的对象是收不到OnSelect事件的，currentSelectedGameObject的值也不会被设置的，必须在点击事件里调用这个接口设置选中对象！Ex： public void OnPointerClick(PointerEventData eventData) { print (“OnPointerClick…”); currEvent.SetSelectedGameObject(gameObject); } 不用在场景里找EventSystem对象，EventSystem组件有一个current静态变量，它就是你要的对象，直接EventSystem.current即可使用。","categories":[{"name":"unity","slug":"unity","permalink":"http://hellomrli.github.io/categories/unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"http://hellomrli.github.io/tags/unity/"},{"name":"MonoBehaviour","slug":"MonoBehaviour","permalink":"http://hellomrli.github.io/tags/MonoBehaviour/"}]},{"title":"github 传输速度慢解决方法","slug":"github 传输速度慢解决方法","date":"2017-01-09T04:47:15.000Z","updated":"2017-01-09T15:36:10.000Z","comments":true,"path":"2017/01/09/github 传输速度慢解决方法/","link":"","permalink":"http://hellomrli.github.io/2017/01/09/github 传输速度慢解决方法/","excerpt":"github被防火长城限制了？？怎么办？","text":"github被防火长城限制了？？怎么办？ 原来是这个域名github.global.ssl.fastly.NET被限制。很简单，去查查这个域名对应的ip，然后修改自己电脑的hosts文件 查询地址：http://tool.chinaz.com/dns 选择一个最小的TTL值，最小一般为30 然后打开C-&gt;windows-&gt;system32-&gt;driver-&gt;etc-&gt;hosts,在最后一行加入如下一句： 151.101.72.249 github.global.ssl.fastly.Net 这样本来5-6k的传输速度提高到600k左右了！！","categories":[{"name":"github","slug":"github","permalink":"http://hellomrli.github.io/categories/github/"}],"tags":[{"name":"github","slug":"github","permalink":"http://hellomrli.github.io/tags/github/"}]},{"title":"Unity3d之MonoBehaviour的可重写函数整理","slug":"Unity3d之MonoBehaviour的可重写函数整理","date":"2017-01-09T04:47:15.000Z","updated":"2017-01-09T04:52:02.000Z","comments":true,"path":"2017/01/09/Unity3d之MonoBehaviour的可重写函数整理/","link":"","permalink":"http://hellomrli.github.io/2017/01/09/Unity3d之MonoBehaviour的可重写函数整理/","excerpt":"Update 当MonoBehaviour启用时，其Update在每一帧被调用。","text":"Update 当MonoBehaviour启用时，其Update在每一帧被调用。 LateUpdate 当Behaviour启用时，其LateUpdate在每一帧被调用。 FixedUpdate 当MonoBehaviour启用时，其 FixedUpdate 在每一帧被调用。 Awake 当一个脚本实例被载入时Awake被调用。 Start Start仅在Update函数第一次被调用前调用。 Reset 重置为默认值。 OnMouseEnter 当鼠标进入到GUIElement(GUI元素)或Collider(碰撞体)中时调用OnMouseEnter。 OnMouseOver 当鼠标悬浮在GUIElement(GUI元素)或Collider(碰撞体)上时调用 OnMouseOver . OnMouseExit 当鼠标移出GUIElement(GUI元素)或Collider(碰撞体)上时调用OnMouseExit。 OnMouseDown 当鼠标在GUIElement(GUI元素)或Collider(碰撞体)上点击时调用OnMouseDown。 OnMouseUp 当用户释放鼠标按钮时调用OnMouseUp。 OnMouseUpAsButton OnMouseUpAsButton只有当鼠标在同一个GUIElement或Collider按下，在释放时调用。 OnMouseDrag 当用户鼠标拖拽GUIElement(GUI元素)或Collider(碰撞体)时调用 OnMouseDrag 。 OnTriggerEnter 当Collider(碰撞体)进入trigger(触发器)时调用OnTriggerEnter。 OnTriggerExit 当Collider(碰撞体)停止触发trigger(触发器)时调用OnTriggerExit。 OnTriggerStay 当碰撞体接触触发器时，OnTriggerStay将在每一帧被调用。 OnCollisionEnter 当此collider/rigidbody触发另一个rigidbody/collider时，OnCollisionEnter将被调用。 OnCollisionExit 当此collider/rigidbody停止触发另一个rigidbody/collider时，OnCollisionExit将被调用。 OnCollisionStay 当此collider/rigidbody触发另一个rigidbody/collider时，OnCollisionStay将会在每一帧被调用。 OnControllerColliderHit 在移动的时，当controller碰撞到collider时OnControllerColliderHit被调用。 OnJointBreak 当附在同一对象上的关节被断开时调用。 OnParticleCollision 当粒子碰到collider时被调用。 OnBecameVisible 当renderer(渲染器)在任何相机上可见时调用OnBecameVisible。 OnBecameInvisible 当renderer(渲染器)在任何相机上都不可见时调用OnBecameInvisible。 OnLevelWasLoaded 当一个新关卡被载入时此函数被调用。 OnEnable 当对象变为可用或激活状态时此函数被调用。 OnDisable 当对象变为不可用或非激活状态时此函数被调用。 OnDestroy 当MonoBehaviour将被销毁时，这个函数被调用。 OnPreCull 在相机消隐场景之前被调用。 OnPreRender 在相机渲染场景之前被调用。 OnPostRender 在相机完成场景渲染之后被调用。 OnRenderObject 在相机场景渲染完成后被调用。 OnWillRenderObject 如果对象可见每个相机都会调用它。 OnGUI 渲染和处理GUI事件时调用。 OnRenderImage 当完成所有渲染图片后被调用，用来渲染图片后期效果。 OnDrawGizmosSelected 如果你想在物体被选中时绘制gizmos，执行这个函数。 OnDrawGizmos 如果你想绘制可被点选的gizmos，执行这个函数。 OnApplicationPause 当玩家暂停时发送到所有的游戏物体。 OnApplicationFocus 当玩家获得或失去焦点时发送给所有游戏物体。 OnApplicationQuit 在应用退出之前发送给所有的游戏物体。 OnPlayerConnected 当一个新玩家成功连接时在服务器上被调用。 OnServerInitialized 当Network.InitializeServer被调用并完成时，在服务器上调用这个函数。 OnConnectedToServer 当你成功连接到服务器时，在客户端调用。 OnPlayerDisconnected 当一个玩家从服务器上断开时在服务器端调用。 OnDisconnectedFromServer 当失去连接或从服务器端断开时在客户端调用。 OnFailedToConnect 当一个连接因为某些原因失败时在客户端调用。 OnFailedToConnectToMasterServer 当报告事件来自主服务器时在客户端或服务器端调用。 OnMasterServerEvent 当报告事件来自主服务器时在客户端或服务器端调用。 OnNetworkInstantiate 当一个物体使用Network.Instantiate进行网络初始化时调用。 OnSerializeNetworkView 在一个网络视图脚本中，用于自定义变量同步。","categories":[{"name":"unity","slug":"unity","permalink":"http://hellomrli.github.io/categories/unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"http://hellomrli.github.io/tags/unity/"},{"name":"MonoBehaviour","slug":"MonoBehaviour","permalink":"http://hellomrli.github.io/tags/MonoBehaviour/"}]},{"title":"关于开发类库后使用无法看到注释的解决方法","slug":"关于开发类库后使用无法看到注释的解决方法","date":"2017-01-09T04:47:15.000Z","updated":"2017-01-09T04:59:36.000Z","comments":true,"path":"2017/01/09/关于开发类库后使用无法看到注释的解决方法/","link":"","permalink":"http://hellomrli.github.io/2017/01/09/关于开发类库后使用无法看到注释的解决方法/","excerpt":"","text":"使用三个斜杠的格式方法注释的格式： 123456/// &lt;summary&gt; /// 这是一个方法的注释，类其他都一样/// &lt;/summary&gt;void Method()&#123;&#125; 设置类库生存xml，并拷贝到引用的地方 具体设置是：项目右键—&gt;属性—&gt;生成—&gt;XML文档文件选中再编译 引用动态类库时，把类库和同名的xml文件放到同一个文件夹内即可。","categories":[{"name":"C#","slug":"C","permalink":"http://hellomrli.github.io/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://hellomrli.github.io/tags/C/"},{"name":"类库","slug":"类库","permalink":"http://hellomrli.github.io/tags/类库/"}]},{"title":"SQL链接异常总结","slug":"SQL链接异常总结","date":"2017-01-08T04:12:06.000Z","updated":"2017-01-08T04:41:14.000Z","comments":true,"path":"2017/01/08/SQL链接异常总结/","link":"","permalink":"http://hellomrli.github.io/2017/01/08/SQL链接异常总结/","excerpt":"","text":"无法远程链接 使用ip地址链接异常，重启msserver服务。","categories":[{"name":"MSSQL","slug":"MSSQL","permalink":"http://hellomrli.github.io/categories/MSSQL/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://hellomrli.github.io/tags/sql/"},{"name":"sql异常","slug":"sql异常","permalink":"http://hellomrli.github.io/tags/sql异常/"}]},{"title":"gihub简易教程","slug":"github简易教程","date":"2017-01-07T15:31:32.000Z","updated":"2017-02-05T08:52:06.000Z","comments":true,"path":"2017/01/07/github简易教程/","link":"","permalink":"http://hellomrli.github.io/2017/01/07/github简易教程/","excerpt":"#什么是 Github?github是一个基于git的代码托管平台，付费用户可以建私人仓库，我们一般的免费用户只能使用公共仓库，也就是代码要公开。Github 由Chris Wanstrath, PJ Hyett 与Tom Preston-Werner三位开发者在2008年4月创办。迄今拥有59名全职员工，主要提供基于git的版本托管服务。","text":"#什么是 Github?github是一个基于git的代码托管平台，付费用户可以建私人仓库，我们一般的免费用户只能使用公共仓库，也就是代码要公开。Github 由Chris Wanstrath, PJ Hyett 与Tom Preston-Werner三位开发者在2008年4月创办。迄今拥有59名全职员工，主要提供基于git的版本托管服务。 #github教程 ##1、注册github账户github官网地址：https://github.com/。 注册比较简单，不在赘述。 ##2、创建仓库图中：1处填写仓库名称，任意填写。2处填写描述，可选。其他默认。点击按钮【create repository】创建仓库。 创建成功后如下图：我创建的仓库名为 TestRepository。图中红色框内有两种服务器地址可以使用，这里先不用管。后面我们会配置SSH，以后都使用SSH，因为使用SSH上传和下载都要快点（别人说的，错了别怪我！！） ##3、下载安装github官网下载比较慢，反正我是等不了，在网上找了一个不是最新的版本，大家也可以使用。链接：http://pan.baidu.com/s/1eSgdavS 密码：azyv安装过程就一直接受，下一步就行了。 ##4、配置Git首先在本地创建ssh key安装好github后，在你的电脑桌面上或者任意一个文件夹下右键鼠标，这时多了两个选项：Git GUI here 和Git Bash Here，我们使用Git Bash Here。弹出一个命令窗口，以后我们也会经常用到它，如下图:接下来我们将会输入一系列的命令来完成git配置。 首先输入如下命令1$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot; 后面的your_email@youremail.com中的youremail改为你在github上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行（按3次回车）。成功的话会在C盘下生成.ssh文件夹，如下图，注意路径，Lisir是我的电脑用户名，你们自己对照自己的。 进去，打开id_rsa.pub，复制里面的key。 回到github上点击setting,进入如下界面， 点击红色框,进入如下界面，这里大家可以看到我已经有两个key了，说明一个帐号可以对应多个key，这样就方便你在公司做的项目和你在家里也可以同步更新继续做 点击New SSH key,进入如下界面title的地方随意写，可以写公司，家里等，key地方粘贴你的电脑上复制的key,add完成。 为了验证是否成功，在git bash下输入： 1$ ssh -T git@github.com 如果是第一次的会提示是否continue，输入yes就会看到：You’ve successfully authenticated, but GitHub does not provide shell access 。这就表示已成功连上github。接下来我们要做的就是把本地仓库传到github上去，在此之前还需要设置username和email，因为github每次commit都会记录他们。12$ git config --global user.name &quot;your name&quot;$ git config --global user.email &quot;your_email@youremail.com&quot; 进入要上传的仓库，右键git bash，添加远程地址：1$ git remote add origin git@github.com:yourName/yourRepo.git 后面的yourName和yourRepo表示你再github的用户名和刚才新建的仓库，加完之后进入.git，打开config，这里会多出一个remote “origin”内容，这就是刚才添加的远程地址，也可以直接修改config来配置远程地址。创建新文件夹，打开，然后执行 git init 以创建新的 git 仓库。检出仓库 1$ git clone git@github.com:HelloMrLi/TestRepository.git git@github.com:HelloMrLi/TestRepository.git 这个是我创建的SSH地址，你们可以在这里查看你们自己的，点击右边红色框可以直接复制，然后替换上面的到此，你就可以把你刚刚创建的仓库的内容克隆到自己当前的文件夹下， 你可以在你的文件下添加文件，注意添加文件夹，如果是空的好像是不能上传的。你就添加一个文本文件，然后测试，一般你要把某个文件夹作为一个本地仓库，需要进行以下命令操作 12345$ git init //把当前文件夹作为本地仓库初始化$ git add . //添加所有文件，.代表所有文件$ git commit -m &quot;代码提交信息&quot;$ git remote add origin &lt;server&gt; //注意 &lt;server&gt; 替换为 git@github.com:yourname/yourrepository.git （yourname为你的名称，yourrepository为你的仓库名称，整个实际上就是你的SSH地址）$ git push origin master 到此你应该就可以上传了。 如果你在其他电脑上更新了新的东东到服务器，你现在需要使用 1$ git pull 该命令会fetch 和merge,获取服务器的合并到本地。 到此你应该可以随心所遇的多地上传更新了。 有问题欢迎留言。","categories":[{"name":"github","slug":"github","permalink":"http://hellomrli.github.io/categories/github/"}],"tags":[{"name":"github","slug":"github","permalink":"http://hellomrli.github.io/tags/github/"}]}]}